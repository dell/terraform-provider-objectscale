package provider

import (
	"context"
	"strings"
	"terraform-provider-objectscale/internal/clientgen"
	"terraform-provider-objectscale/internal/helper"
	"terraform-provider-objectscale/internal/models"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ datasource.DataSource = &NamespaceDataSource{}

func NewNamespaceDataSource() datasource.DataSource {
	return &NamespaceDataSource{}
}

type NamespaceDataSource struct {
	datasourceProviderConfig
}

func (d *NamespaceDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_namespace"
}

// Schema describes the data source arguments.
func (d *NamespaceDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "This data source retrieves an existing Dell ObjectScale namespace and gives its configuration (e.g.tenant)",
		Description:         "This data source retrieves an existing Dell ObjectScale namespace and gives its configuration (e.g.tenant)",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Description:         "Identifier",
				MarkdownDescription: "Identifier",
				Computed:            true,
			},
			"name": schema.StringAttribute{
				Description:         "Name or name prefix (ending with a '*') of namespace(s) to be fetched.",
				MarkdownDescription: "Name or name prefix (ending with a '*') of namespace(s) to be fetched.",
				Optional:            true,
			},
			"namespaces": schema.ListNestedAttribute{
				Description:         "List of Namespaces",
				MarkdownDescription: "List of Namespaces",
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Description:         "Name assigned to this resource in ObjectScale. The resource name is set by a user and can be changed at any time. It is not a unique identifier.",
							MarkdownDescription: "Name assigned to this resource in ObjectScale. The resource name is set by a user and can be changed at any time. It is not a unique identifier.",
							Computed:            true,
						},
						"id": schema.StringAttribute{
							Description:         "Identifier that is generated by ObjectScale when the resource is created. The resource Id is guaranteed to be unique and immutable across all virtual data centers for all time.",
							MarkdownDescription: "Identifier that is generated by ObjectScale when the resource is created. The resource Id is guaranteed to be unique and immutable across all virtual data centers for all time.",
							Computed:            true,
						},
						"global": schema.BoolAttribute{
							Description:         "Indicates whether the resource is global.",
							MarkdownDescription: "Indicates whether the resource is global.",
							Computed:            true,
						},
						"remote": schema.BoolAttribute{
							Description:         "Indicates whether the resource is remote.",
							MarkdownDescription: "Indicates whether the resource is remote.",
							Computed:            true,
						},
						"link": schema.SingleNestedAttribute{
							Description:         "Hyperlink to the details for this resource.",
							MarkdownDescription: "Hyperlink to the details for this resource.",
							Computed:            true,
							Attributes: map[string]schema.Attribute{
								"rel": schema.StringAttribute{
									Description:         "Rel.",
									MarkdownDescription: "Rel.",
									Computed:            true,
								},
								"href": schema.StringAttribute{
									Description:         "Href.",
									MarkdownDescription: "Href.",
									Computed:            true,
								},
							},
						},
						"creation_time": schema.Int64Attribute{
							Description:         "Timestamp that shows when this resource was created in ObjectScale.",
							MarkdownDescription: "Timestamp that shows when this resource was created in ObjectScale.",
							Computed:            true,
						},
						"inactive": schema.BoolAttribute{
							Description:         "Indicates whether the resource is inactive. When a user removes a resource, the resource is put in this state before it is removed from the ObjectScale database.",
							MarkdownDescription: "Indicates whether the resource is inactive. When a user removes a resource, the resource is put in this state before it is removed from the ObjectScale database.",
							Computed:            true,
						},
						"internal": schema.BoolAttribute{
							Description:         "Indicated whether the resource is an internal resource.",
							MarkdownDescription: "Indicated whether the resource is an internal resource.",
							Computed:            true,
						},
						"default_data_services_vpool": schema.StringAttribute{
							Description:         "Default replication group identifier for this tenant when creating buckets.",
							MarkdownDescription: "Default replication group identifier for this tenant when creating buckets.",
							Required:            true,
						},
						"allowed_vpools_list": schema.ListAttribute{
							Description:         "List of replication group that are allowed access to namespace.",
							MarkdownDescription: "List of replication group that are allowed access to namespace.",
							Computed:            true,
							ElementType:         types.StringType,
						},
						"disallowed_vpools_list": schema.ListAttribute{
							Description:         "List of replication group that are not allowed access to namespace.",
							MarkdownDescription: "List of replication group that are not allowed access to namespace.",
							Computed:            true,
							ElementType:         types.StringType,
						},
						"namespace_admins": schema.StringAttribute{
							Description:         "Comma separated list of namespace admins.",
							MarkdownDescription: "Comma separated list of namespace admins.",
							Computed:            true,
						},
						"user_mapping": schema.ListNestedAttribute{
							Description:         "User Mapping.",
							MarkdownDescription: "User Mapping.",
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"domain": schema.StringAttribute{
										Description:         "A single-valued attribute indicating the user's IDP domain",
										MarkdownDescription: "A single-valued attribute indicating the user's IDP domain",
										Computed:            true,
									},
									"groups": schema.ListAttribute{
										Description:         "Groups.",
										MarkdownDescription: "Groups.",
										Computed:            true,
										ElementType:         types.StringType,
									},
									"attributes": schema.ListNestedAttribute{
										Description:         "Attributes.",
										MarkdownDescription: "Attributes.",
										Computed:            true,
										NestedObject: schema.NestedAttributeObject{
											Attributes: map[string]schema.Attribute{
												"key": schema.StringAttribute{
													Description:         "Lookup string for this key-value pair",
													MarkdownDescription: "Lookup string for this key-value pair",
													Computed:            true,
												},
												"value": schema.ListAttribute{
													Description:         "Lookup result for this key-value pair.",
													MarkdownDescription: "Lookup result for this key-value pair.",
													Computed:            true,
													ElementType:         types.StringType,
												},
											},
										},
									},
								},
							},
						},
						"is_encryption_enabled": schema.BoolAttribute{
							Description:         "Encryption status of the namesapce.",
							MarkdownDescription: "Encryption status of the namesapce.",
							Computed:            true,
						},
						"default_bucket_block_size": schema.Int64Attribute{
							Description:         "Default bucket quota size.",
							MarkdownDescription: "Default bucket quota size.",
							Computed:            true,
						},
						"external_group_admins": schema.StringAttribute{
							Description:         "List of groups from AD Server.",
							MarkdownDescription: "List of groups from AD Server.",
							Computed:            true,
						},
						"is_stale_allowed": schema.BoolAttribute{
							Description:         "Namespace isStaleAllowed flag.",
							MarkdownDescription: "Namespace isStaleAllowed flag.",
							Computed:            true,
						},
						"is_object_lock_with_ado_allowed": schema.BoolAttribute{
							Description:         "Defines the default behavior for allowing Object Lock with ADO on new buckets created in the namespace.",
							MarkdownDescription: "Defines the default behavior for allowing Object Lock with ADO on new buckets created in the namespace.",
							Computed:            true,
						},
						"is_compliance_enabled": schema.BoolAttribute{
							Description:         "Namespace isComplianceEnabled flag.",
							MarkdownDescription: "Namespace isComplianceEnabled flag.",
							Computed:            true,
						},
						"notification_size": schema.Int64Attribute{
							Description:         "Notification Size in GB.",
							MarkdownDescription: "Notification Size in GB.",
							Computed:            true,
						},
						"block_size": schema.Int64Attribute{
							Description:         "Block Size in GB.",
							MarkdownDescription: "Block Size in GB.",
							Computed:            true,
						},
						"notification_size_in_count": schema.Int64Attribute{
							Description:         "Notification Size in Count.",
							MarkdownDescription: "Notification Size in Count.",
							Computed:            true,
						},
						"block_size_in_count": schema.Int64Attribute{
							Description:         "Block Size in Count.",
							MarkdownDescription: "Block Size in Count.",
							Computed:            true,
						},
						"default_audit_delete_expiration": schema.Int64Attribute{
							Description:         "Default bucket audit delete expiration.",
							MarkdownDescription: "Default bucket audit delete expiration.",
							Computed:            true,
						},
						"retention_classes": schema.SingleNestedAttribute{
							Description:         "RetentionClasses.",
							MarkdownDescription: "RetentionClasses.",
							Computed:            true,
							Attributes: map[string]schema.Attribute{
								"retention_class": schema.ListNestedAttribute{
									Description:         "Retention Class.",
									MarkdownDescription: "Retention Class.",
									Computed:            true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Description:         "Name of the retention class.",
												MarkdownDescription: "Name of the retention class.",
												Computed:            true,
											},
											"period": schema.Int64Attribute{
												Description:         "Period of the retention class in seconds.",
												MarkdownDescription: "Period of the retention class in seconds.",
												Computed:            true,
											},
										},
									},
								},
							},
						},
						"root_user_name": schema.StringAttribute{
							Description:         "root user name.",
							MarkdownDescription: "root user name.",
							Computed:            true,
						},
					},
				},
			},
		},
	}
}

func (d *NamespaceDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data models.NamespaceDatasourceModel

	// Read Terraform configuration data into the model
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	name := helper.ValueToPointer[string](data.Name)
	var err error
	var allNsResp []clientgen.NamespaceServiceGetNamespacesResponseNamespaceInner

	if name == nil {
		dsreq := d.client.GenClient.NamespaceApi.NamespaceServiceGetNamespaces(ctx)
		allNsResp, err = helper.GetAllInstances(dsreq)
	} else if strings.HasSuffix(*name, "*") {
		dsreq := d.client.GenClient.NamespaceApi.NamespaceServiceGetNamespaces(ctx).Name(*name)
		allNsResp, err = helper.GetAllInstances(dsreq)
	} else {
		NsResp, _, verr := d.client.GenClient.NamespaceApi.NamespaceServiceGetNamespace(ctx, *name).Execute()
		err = verr
		if err == nil {
			allNsResp = append(allNsResp, clientgen.NamespaceServiceGetNamespacesResponseNamespaceInner{
				DefaultDataServicesVpool:     NsResp.DefaultDataServicesVpool,
				AllowedVpoolsList:            NsResp.AllowedVpoolsList,
				DisallowedVpoolsList:         NsResp.DisallowedVpoolsList,
				NamespaceAdmins:              NsResp.NamespaceAdmins,
				IsEncryptionEnabled:          NsResp.IsEncryptionEnabled,
				UserMapping:                  NsResp.UserMapping,
				DefaultBucketBlockSize:       NsResp.DefaultBucketBlockSize,
				ExternalGroupAdmins:          NsResp.ExternalGroupAdmins,
				IsStaleAllowed:               NsResp.IsStaleAllowed,
				IsObjectLockWithAdoAllowed:   NsResp.IsObjectLockWithAdoAllowed,
				IsComplianceEnabled:          NsResp.IsComplianceEnabled,
				NotificationSize:             NsResp.NotificationSize,
				BlockSize:                    NsResp.BlockSize,
				RetentionClasses:             NsResp.RetentionClasses,
				DefaultAuditDeleteExpiration: NsResp.DefaultAuditDeleteExpiration,
				RootUserName:                 NsResp.RootUserName,
				Name:                         NsResp.Name,
				Id:                           NsResp.Id,
				Link:                         NsResp.Link,
				CreationTime:                 NsResp.CreationTime,
				Inactive:                     NsResp.Inactive,
				Global:                       NsResp.Global,
				Remote:                       NsResp.Remote,
				Vdc:                          NsResp.Vdc,
				Internal:                     NsResp.Internal,
			})
		}
	}

	if err != nil {
		resp.Diagnostics.AddError(
			"Error getting namespaces",
			err.Error(),
		)
		return
	}

	namespaceList := d.updateNamespaceState(allNsResp)

	// hardcoding a response value to save into the Terraform state.
	data.ID = types.StringValue("namespace_datasource")
	data.Namespaces = namespaceList

	// Write logs using the tflog package
	// Documentation: https://terraform.io/plugin/log
	tflog.Trace(ctx, "read namespace data source")

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (d NamespaceDataSource) updateNamespaceState(namespaces []clientgen.NamespaceServiceGetNamespacesResponseNamespaceInner) []models.NamespaceEntity {
	return helper.SliceTransform(namespaces, func(v clientgen.NamespaceServiceGetNamespacesResponseNamespaceInner) models.NamespaceEntity {
		IsEncryptionEnabled := v.IsEncryptionEnabled != nil && *v.IsEncryptionEnabled == "true"
		return models.NamespaceEntity{
			Name:   helper.TfString(v.Name),
			Id:     helper.TfString(v.Id),
			Global: helper.TfBool(v.Global),
			Remote: helper.TfBool(v.Remote),
			Link: models.TenancyLink{
				Rel:  helper.TfString(v.Link.Rel),
				Href: helper.TfString(v.Link.Href),
			},
			CreationTime:             types.Int64PointerValue(v.CreationTime),
			Inactive:                 helper.TfBool(v.Inactive),
			Internal:                 helper.TfBool(v.Internal),
			DefaultDataServicesVpool: helper.TfString(v.DefaultDataServicesVpool),
			AllowedVpoolsList:        helper.SliceTransform(v.AllowedVpoolsList, types.StringValue),
			DisallowedVpoolsList:     helper.SliceTransform(v.DisallowedVpoolsList, types.StringValue),
			NamespaceAdmins:          helper.TfString(v.NamespaceAdmins),
			UserMapping: helper.SliceTransform(v.UserMapping, func(vi clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerUserMappingInner) models.UserMapping {
				return models.UserMapping{
					Domain: types.StringValue(vi.Domain),
					Attributes: helper.SliceTransform(vi.Attributes, func(via clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerUserMappingInnerAttributesInner) models.Attribute {
						return models.Attribute{
							Key:   types.StringValue(via.Key),
							Value: helper.SliceTransform(via.Value, types.StringValue),
						}
					}),
					Groups: helper.SliceTransform(vi.Groups, types.StringValue),
				}
			}),
			IsEncryptionEnabled:          types.BoolValue(IsEncryptionEnabled),
			DefaultBucketBlockSize:       helper.TfInt64(v.DefaultBucketBlockSize),
			ExternalGroupAdmins:          helper.TfString(v.ExternalGroupAdmins),
			IsStaleAllowed:               helper.TfBool(v.IsStaleAllowed),
			IsObjectLockWithAdoAllowed:   helper.TfBool(v.IsObjectLockWithAdoAllowed),
			IsComplianceEnabled:          helper.TfBool(v.IsComplianceEnabled),
			NotificationSize:             helper.TfInt64(v.NotificationSize),
			BlockSize:                    helper.TfInt64(v.BlockSize),
			NotificationSizeInCount:      helper.TfInt64(v.NotificationSizeInCount),
			BlockSizeInCount:             helper.TfInt64(v.BlockSizeInCount),
			DefaultAuditDeleteExpiration: helper.TfInt64(v.DefaultAuditDeleteExpiration),
			RetentionClasses: models.RetentionClasses{
				RetentionClass: helper.SliceTransform(func(in *clientgen.NamespaceServiceGetNamespacesResponseNamespaceInner) []clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerRetentionClassesRetentionClassInner {
					if in.RetentionClasses == nil {
						return make([]clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerRetentionClassesRetentionClassInner, 0)
					}
					return in.RetentionClasses.RetentionClass
				}(&v), func(vr clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerRetentionClassesRetentionClassInner) models.RetentionClass {
					return models.RetentionClass{
						Name:   helper.TfString(vr.Name),
						Period: helper.TfInt64(vr.Period),
					}
				}),
			},
			RootUserName: helper.TfString(v.RootUserName),
		}
	})
}
