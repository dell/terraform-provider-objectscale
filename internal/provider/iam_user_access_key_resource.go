/*
Copyright (c) 2025 Dell Inc., or its subsidiaries. All Rights Reserved.

Licensed under the Mozilla Public License Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://mozilla.org/MPL/2.0/


Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package provider

import (
	"context"
	"strings"

	"terraform-provider-objectscale/internal/helper"
	"terraform-provider-objectscale/internal/models"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"

	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &IAMUserAccessKeyResource{}
var _ resource.ResourceWithImportState = &IAMUserAccessKeyResource{}

func NewIAMUserAccessKeyResource() resource.Resource {
	return &IAMUserAccessKeyResource{}
}

// IAMUserAccessKeyResource defines the resource implementation.
type IAMUserAccessKeyResource struct {
	resourceProviderConfig
}

func (r *IAMUserAccessKeyResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_iam_user_access_key"
}

func (r *IAMUserAccessKeyResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "This resource Enables the creation and management of secure programmatic access for ObjectScale users by provisioning and controlling S3 compatible access keys.",
		Description:         "This resource Enables the creation and management of secure programmatic access for ObjectScale users by provisioning and controlling S3 compatible access keys.",
		Attributes: map[string]schema.Attribute{
			"username": schema.StringAttribute{
				Description:         "Name of the user to which the key is attached. Required.",
				MarkdownDescription: "Name of the user to which the key is attached. Required.",
				Required:            true,
			},
			"id": schema.StringAttribute{
				Description:         "Identifier that is generated by ObjectScale when the resource is created.",
				MarkdownDescription: "Identifier that is generated by ObjectScale when the resource is created.",
				Computed:            true,
			},
			"status": schema.StringAttribute{
				Description:         "Status of the access key attached to the user.",
				MarkdownDescription: "Status of the access key attached to the user.",
				Optional:            true,
				Computed:            true,
				Validators: []validator.String{
					stringvalidator.OneOf(
						"Active",
						"Inactive",
					),
				},
			},
			"namespace": schema.StringAttribute{
				Description:         "Namespace to which the user belongs to.",
				MarkdownDescription: "Namespace to which the user belongs to.",
				Required:            true,
			},
			"secret_access_key": schema.StringAttribute{
				Description:         "Secret access key associated with the user.",
				MarkdownDescription: "Secret access key associated with the user.",
				Computed:            true,
				Sensitive:           true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"create_date": schema.StringAttribute{
				Description:         "Creation date of the access key.",
				MarkdownDescription: "Creation date of the access key.",
				Computed:            true,
			},
		},
	}
}

func (r *IAMUserAccessKeyResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Info(ctx, "creating access key")
	var plan models.IAMUserAccessKeyResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)

	if resp.Diagnostics.HasError() {
		return
	}

	create_access_key, _, err := r.client.GenClient.IamApi.IamServiceCreateAccessKey(ctx).
		UserName(plan.UserName.ValueString()).
		XEmcNamespace(plan.Namespace.ValueString()).
		Execute()
	if err != nil {
		resp.Diagnostics.AddError("Error creating acess key for the user", err.Error())
		return
	}
	// ---- fetch access keys ----
	kResp, _, err := r.client.GenClient.IamApi.
		IamServiceListAccessKeys(ctx).
		UserName(plan.UserName.ValueString()).
		XEmcNamespace(plan.Namespace.ValueString()).
		Execute()

	if err != nil {
		resp.Diagnostics.AddError("Error reading user access key", err.Error())
		return
	}

	var data models.IAMUserAccessKeyResourceModel
	if kResp != nil && kResp.ListAccessKeysResult != nil {
		for _, k := range kResp.ListAccessKeysResult.AccessKeyMetadata {
			if *k.AccessKeyId == *create_access_key.CreateAccessKeyResult.AccessKey.AccessKeyId {
				data = models.IAMUserAccessKeyResourceModel{
					Id:              helper.TfString(k.AccessKeyId),
					CreateDate:      helper.TfString(k.CreateDate),
					Status:          helper.TfString(k.Status),
					UserName:        helper.TfString(k.UserName),
					Namespace:       plan.Namespace,
					SecretAccessKey: helper.TfString(create_access_key.CreateAccessKeyResult.AccessKey.SecretAccessKey),
				}
				break
			}
		}
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *IAMUserAccessKeyResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	tflog.Info(ctx, "Reading user access key")
	var state models.IAMUserAccessKeyResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	kResp, _, err := r.client.GenClient.IamApi.
		IamServiceListAccessKeys(ctx).
		UserName(state.UserName.ValueString()).
		XEmcNamespace(state.Namespace.ValueString()).
		Execute()

	if err != nil {
		resp.Diagnostics.AddError("Error reading user access key", err.Error())
		return
	}
	var data models.IAMUserAccessKeyResourceModel
	if kResp != nil && kResp.ListAccessKeysResult != nil {
		for _, k := range kResp.ListAccessKeysResult.AccessKeyMetadata {
			if *k.AccessKeyId == state.Id.ValueString() {
				data = models.IAMUserAccessKeyResourceModel{
					Id:              helper.TfString(k.AccessKeyId),
					CreateDate:      helper.TfString(k.CreateDate),
					Status:          helper.TfString(k.Status),
					UserName:        helper.TfString(k.UserName),
					Namespace:       state.Namespace,
					SecretAccessKey: helper.TfString(state.SecretAccessKey.ValueStringPointer()),
				}
				break
			}
		}
	}
	// Save updated plan into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *IAMUserAccessKeyResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	tflog.Info(ctx, "Updating user access key")

	var plan, state models.IAMUserAccessKeyResourceModel

	// Read Terraform plan and state data
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	if helper.IsChangedNN(plan.Status, state.Status) {
		_, _, err := r.client.GenClient.IamApi.IamServiceUpdateAccessKey(ctx).
			AccessKeyId(state.Id.ValueString()).
			UserName(plan.UserName.ValueString()).
			Status(plan.Status.ValueString()).
			XEmcNamespace(plan.Namespace.ValueString()).
			Execute()

		if err != nil {
			resp.Diagnostics.AddError("Error updating access key status", err.Error())
			return
		}
	}

	kResp, _, err := r.client.GenClient.IamApi.
		IamServiceListAccessKeys(ctx).
		UserName(state.UserName.ValueString()).
		XEmcNamespace(state.Namespace.ValueString()).
		Execute()

	if err != nil {
		resp.Diagnostics.AddError("Error reading user access key", err.Error())
		return
	}

	var data models.IAMUserAccessKeyResourceModel
	if kResp != nil && kResp.ListAccessKeysResult != nil {
		for _, k := range kResp.ListAccessKeysResult.AccessKeyMetadata {
			if *k.AccessKeyId == state.Id.ValueString() {
				data = models.IAMUserAccessKeyResourceModel{
					Id:              helper.TfString(k.AccessKeyId),
					CreateDate:      helper.TfString(k.CreateDate),
					Status:          helper.TfString(k.Status),
					UserName:        helper.TfString(k.UserName),
					Namespace:       state.Namespace,
					SecretAccessKey: helper.TfString(state.SecretAccessKey.ValueStringPointer()),
				}
				break
			}
		}
	}
	// Save updated plan into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)

}

func (r *IAMUserAccessKeyResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	tflog.Info(ctx, "Deleting IAM user access key")
	var state models.IAMUserAccessKeyResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	_, _, err := r.client.GenClient.IamApi.IamServiceDeleteAccessKey(ctx).
		AccessKeyId(state.Id.ValueString()).
		UserName(state.UserName.ValueString()).
		XEmcNamespace(state.Namespace.ValueString()).
		Execute()

	if err != nil {
		resp.Diagnostics.AddError(
			"Error Deleting IAM user access key",
			err.Error(),
		)
	}
}

func (r *IAMUserAccessKeyResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	tflog.Info(ctx, "Importing IAM user access key")

	parts := strings.SplitN(req.ID, ":", 3)
	if len(parts) != 3 {
		resp.Diagnostics.AddError("Error importing IAM user access key", "invalid format: expected 'accesskeyId:username:namespace'")
		return
	}

	accessKeyId := parts[0]
	username := parts[1]
	namespace := parts[2]

	kResp, _, err := r.client.GenClient.IamApi.
		IamServiceListAccessKeys(ctx).
		UserName(username).
		XEmcNamespace(namespace).
		Execute()

	if err != nil {
		resp.Diagnostics.AddError("Error reading user access key", err.Error())
		return
	}
	var data models.IAMUserAccessKeyResourceModel
	if kResp != nil && kResp.ListAccessKeysResult != nil {
		for _, k := range kResp.ListAccessKeysResult.AccessKeyMetadata {
			if *k.AccessKeyId == accessKeyId {
				data = models.IAMUserAccessKeyResourceModel{
					Id:              helper.TfString(k.AccessKeyId),
					CreateDate:      helper.TfString(k.CreateDate),
					Status:          helper.TfString(k.Status),
					UserName:        helper.TfString(k.UserName),
					Namespace:       types.StringValue(namespace),
					SecretAccessKey: types.StringValue(""),
				}
				break
			}
		}
	}
	// Save updated plan into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)

}
