package provider

import (
	"context"
	"terraform-provider-objectscale/internal/helper"
	"terraform-provider-objectscale/internal/models"

	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ datasource.DataSource = &ReplicationGroupDataSource{}

func NewReplicationGroupDataSource() datasource.DataSource {
	return &ReplicationGroupDataSource{}
}

type ReplicationGroupDataSource struct {
	datasourceProviderConfig
}

func (d *ReplicationGroupDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_replication_group"
}

// Schema describes the data source arguments.
func (d *ReplicationGroupDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "ObjectScale Replication Group Data Source to get all replication groups details.",
		Description:         "ObjectScale Replication Group Data Source to get all replication groups details.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Description:         "Identifier",
				MarkdownDescription: "Identifier",
				Computed:            true,
			},
			"replication_groups": schema.ListNestedAttribute{
				Description:         "List of Replication Groups",
				MarkdownDescription: "List of Replication Groups",
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"description": schema.StringAttribute{
							Description:         "Description of the replication group.",
							MarkdownDescription: "Description of the replication group.",
							Computed:            true,
						},
						"name": schema.StringAttribute{
							Description:         "Name assigned to this resource in ECS. The resource name is set by a user and can be changed at any time. It is not a unique identifier.",
							MarkdownDescription: "Name assigned to this resource in ECS. The resource name is set by a user and can be changed at any time. It is not a unique identifier.",
							Computed:            true,
						},
						"enable_rebalancing": schema.BoolAttribute{
							Description:         "Indicates if rebalancing is enabled.",
							MarkdownDescription: "Indicates if rebalancing is enabled.",
							Computed:            true,
						},
						"is_allow_all_namespaces": schema.BoolAttribute{
							Description:         "Indicates if the replication group can access all namespaces.",
							MarkdownDescription: "Indicates if the replication group can access all namespaces.",
							Computed:            true,
						},
						"is_full_rep": schema.BoolAttribute{
							Description:         "Indicates if full replication is enabled.",
							MarkdownDescription: "Indicates if full replication is enabled.",
							Computed:            true,
						},
						"use_replication_target": schema.BoolAttribute{
							Description:         "Indicates if replication target is used.",
							MarkdownDescription: "Indicates if replication target is used.",
							Computed:            true,
						},
						"id": schema.StringAttribute{
							Description:         "Unique identifier generated by ECS.",
							MarkdownDescription: "Unique identifier generated by ECS.",
							Computed:            true,
						},
						"creation_time": schema.Int64Attribute{
							Description:         "Timestamp when resource was created.",
							MarkdownDescription: "Timestamp when resource was created.",
							Computed:            true,
						},
						"inactive": schema.BoolAttribute{
							Description:         "Indicates whether the resource is inactive.",
							MarkdownDescription: "Indicates whether the resource is inactive.",
							Computed:            true,
						},
						"global": schema.BoolAttribute{
							Description:         "Indicates whether the resource is global.",
							MarkdownDescription: "Indicates whether the resource is global.",
							Computed:            true,
						},
						"remote": schema.BoolAttribute{
							Description:         "Indicates whether the resource is remote.",
							MarkdownDescription: "Indicates whether the resource is remote.",
							Computed:            true,
						},
						"internal": schema.BoolAttribute{
							Description:         "Indicates whether the resource is internal.",
							MarkdownDescription: "Indicates whether the resource is internal.",
							Computed:            true,
						},
						"vdc": schema.SingleNestedAttribute{
							Description:         "VDC details.",
							MarkdownDescription: "VDC details.",
							Computed:            true,
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Description:         "ECS Id of the related VDC object.",
									MarkdownDescription: "ECS Id of the related VDC object.",
									Computed:            true,
								},
								"link": schema.SingleNestedAttribute{
									Description:         "Hyperlink to VDC details.",
									MarkdownDescription: "Hyperlink to VDC details.",
									Computed:            true,
									Attributes: map[string]schema.Attribute{
										"rel": schema.StringAttribute{
											Description:         "Rel attribute of the VDC link.",
											MarkdownDescription: "Rel attribute of the VDC link.",
											Computed:            true,
										},
										"href": schema.StringAttribute{
											Description:         "Href attribute of the VDC link.",
											MarkdownDescription: "Href attribute of the VDC link.",
											Computed:            true,
										},
									},
								},
							},
						},
						"varray_mappings": schema.ListNestedAttribute{
							Description:         "List of Varray mappings.",
							MarkdownDescription: "List of Varray mappings.",
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										Description:         "Virtual data center ID.",
										MarkdownDescription: "Virtual data center ID.",
										Computed:            true,
									},
									"value": schema.StringAttribute{
										Description:         "Storage pool ID.",
										MarkdownDescription: "Storage pool ID.",
										Computed:            true,
									},
									"is_replication_target": schema.BoolAttribute{
										Description:         "Indicates if this is a replication target.",
										MarkdownDescription: "Indicates if this is a replication target.",
										Computed:            true,
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func (d *ReplicationGroupDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data models.ReplicationGroupDatasourceModel

	// Read Terraform configuration data into the model
	resp.Diagnostics.Append(req.Config.Get(ctx, &data)...)
	if resp.Diagnostics.HasError() {
		return
	}

	allRGResp, _, err := d.client.GenClient.DataVpoolApi.DataServiceVpoolServiceGetDataServiceVpools(ctx).Execute()
	if err != nil {
		resp.Diagnostics.AddError(
			"Error getting the list of replication group",
			err.Error(),
		)
		return
	}

	replicationGroupList := helper.UpdateReplicationGroupState(allRGResp.DataServiceVpool)

	// hardcoding a response value to save into the Terraform state.
	data.ID = types.StringValue("replication_group_datasource")
	data.ReplicationGroups = replicationGroupList

	tflog.Trace(ctx, "read replication group data source")

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
