/*
Copyright (c) 2025 Dell Inc., or its subsidiaries. All Rights Reserved.

Licensed under the Mozilla Public License Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://mozilla.org/MPL/2.0/


Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package provider

import (
	"context"
	"strings"

	"terraform-provider-objectscale/internal/clientgen"
	"terraform-provider-objectscale/internal/helper"
	"terraform-provider-objectscale/internal/models"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"

	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &ObjectUserSecretKeyResource{}
var _ resource.ResourceWithImportState = &ObjectUserSecretKeyResource{}

func NewObjectUserSecretKeyResource() resource.Resource {
	return &ObjectUserSecretKeyResource{}
}

// ObjectUserSecretKeyResource defines the resource implementation.
type ObjectUserSecretKeyResource struct {
	resourceProviderConfig
}

func (r *ObjectUserSecretKeyResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_object_user_secret_key"
}

func (r *ObjectUserSecretKeyResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "ObjectScale supports creation and management of IAM Users within a namespace.",
		Description:         "ObjectScale supports creation and management of IAM Users within a namespace.",
		Attributes: map[string]schema.Attribute{
			"username": schema.StringAttribute{
				Description:         "Name of the user to which the key is attached. Required.",
				MarkdownDescription: "Name of the user to which the key is attached. Required.",
				Required:            true,
			},
			"id": schema.StringAttribute{
				Description:         "Identifier that is generated by ObjectScale when the resource is created.",
				MarkdownDescription: "Identifier that is generated by ObjectScale when the resource is created.",
				Computed:            true,
			},
			"secret_key": schema.StringAttribute{
				Description:         "Secret key associated with the user.",
				MarkdownDescription: "Secret key associated with the user.",
				Computed:            true,
				Sensitive:           true,
				Optional:            true,
			},
			"key_timestamp": schema.StringAttribute{
				Description:         "Timestamp of creation of the key.",
				MarkdownDescription: "Timestamp of creation of the key.",
				Computed:            true,
			},
			"key_expiry_timestamp": schema.StringAttribute{
				Description:         "Expiry timestamp of the key.",
				MarkdownDescription: "Expiry timestamp of the key.",
				Computed:            true,
			},
			"namespace": schema.StringAttribute{
				Description:         "Namespace to which the user belongs to.",
				MarkdownDescription: "Namespace to which the user belongs to.",
				Required:            true,
			},
			"expiry_in_mins": schema.StringAttribute{
				Description:         "Expiry of the existing secret key in minutes.",
				MarkdownDescription: "Expiry of the existing secret key in minutes.",
				Optional:            true,
			},
		},
	}
}

func (r *ObjectUserSecretKeyResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Info(ctx, "creating secret key")
	var plan models.ObjectUserSecretKeyResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)

	if resp.Diagnostics.HasError() {
		return
	}

	create_secret_key_resp := r.client.GenClient.UserSecretKeyApi.UserSecretKeyServiceCreateNewKeyForUser(ctx, plan.UserName.ValueString())
	ns := plan.Namespace.ValueString()
	secret_key := plan.SecretKey.ValueString()

	var (
		createSecretKey *clientgen.UserSecretKeyServiceCreateNewKeyForUserResponse
		err             error
	)

	if !plan.ExpiryInMins.IsNull() && !plan.ExpiryInMins.IsUnknown() {
		expiry_time_mins := plan.ExpiryInMins.ValueString()
		createSecretKey, _, err = create_secret_key_resp.UserSecretKeyServiceCreateNewKeyForUserRequest(
			clientgen.UserSecretKeyServiceCreateNewKeyForUserRequest{
				Namespace:                 &ns,
				ExistingKeyExpiryTimeMins: &expiry_time_mins,
				Secretkey:                 &secret_key,
			}).Execute()
		if err != nil {
			resp.Diagnostics.AddError("Error creating secret key for the user", err.Error())
			return
		}
	} else {
		createSecretKey, _, err = create_secret_key_resp.UserSecretKeyServiceCreateNewKeyForUserRequest(
			clientgen.UserSecretKeyServiceCreateNewKeyForUserRequest{
				Namespace: &ns,
				Secretkey: &secret_key,
			}).Execute()
		if err != nil {
			resp.Diagnostics.AddError("Error creating secret key for the user", err.Error())
			return
		}
	}
	kResp, _, err := r.client.GenClient.UserSecretKeyApi.
		UserSecretKeyServiceGetKeysForUser(ctx, plan.UserName.ValueString()).
		Execute()

	if err != nil {
		resp.Diagnostics.AddError("Error reading user secret key", err.Error())
		return
	}

	var data models.ObjectUserSecretKeyResourceModel
	if kResp != nil {
		if kResp.SecretKey1Id != nil && *kResp.SecretKey1Id == *createSecretKey.SecretKeyId {
			data = models.ObjectUserSecretKeyResourceModel{
				Id:                 helper.TfString(kResp.SecretKey1Id),
				KeyExpiryTimestamp: helper.TfString(kResp.KeyExpiryTimestamp1),
				KeyTimestamp:       helper.TfString(kResp.KeyTimestamp1),
				UserName:           plan.UserName,
				Namespace:          plan.Namespace,
				SecretKey:          helper.TfString(kResp.SecretKey1),
				ExpiryInMins:       plan.ExpiryInMins,
			}
		} else if kResp.SecretKey2Id != nil && *kResp.SecretKey2Id == *createSecretKey.SecretKeyId {
			data = models.ObjectUserSecretKeyResourceModel{
				Id:                 helper.TfString(kResp.SecretKey2Id),
				KeyExpiryTimestamp: helper.TfString(kResp.KeyExpiryTimestamp2),
				KeyTimestamp:       helper.TfString(kResp.KeyTimestamp2),
				UserName:           plan.UserName,
				Namespace:          plan.Namespace,
				SecretKey:          helper.TfString(kResp.SecretKey2),
				ExpiryInMins:       plan.ExpiryInMins,
			}
		}
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ObjectUserSecretKeyResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	tflog.Info(ctx, "Reading user secret key")
	var state models.ObjectUserSecretKeyResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	kResp, _, err := r.client.GenClient.UserSecretKeyApi.
		UserSecretKeyServiceGetKeysForUser(ctx, state.UserName.ValueString()).
		Execute()

	if err != nil {
		resp.Diagnostics.AddError("Error reading user secret key", err.Error())
		return
	}

	var data models.ObjectUserSecretKeyResourceModel
	if kResp != nil {
		if kResp.SecretKey1Id != nil && *kResp.SecretKey1Id == *state.Id.ValueStringPointer() {
			data = models.ObjectUserSecretKeyResourceModel{
				Id:                 helper.TfString(kResp.SecretKey1Id),
				KeyExpiryTimestamp: helper.TfString(kResp.KeyExpiryTimestamp1),
				KeyTimestamp:       helper.TfString(kResp.KeyTimestamp1),
				UserName:           state.UserName,
				Namespace:          state.Namespace,
				SecretKey:          helper.TfString(kResp.SecretKey1),
				ExpiryInMins:       state.ExpiryInMins,
			}
		} else if kResp.SecretKey2Id != nil && *kResp.SecretKey2Id == *state.Id.ValueStringPointer() {
			data = models.ObjectUserSecretKeyResourceModel{
				Id:                 helper.TfString(kResp.SecretKey2Id),
				KeyExpiryTimestamp: helper.TfString(kResp.KeyExpiryTimestamp2),
				KeyTimestamp:       helper.TfString(kResp.KeyTimestamp2),
				UserName:           state.UserName,
				Namespace:          state.Namespace,
				SecretKey:          helper.TfString(kResp.SecretKey2),
				ExpiryInMins:       state.ExpiryInMins,
			}
		}
	}
	// Save updated plan into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *ObjectUserSecretKeyResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	resp.Diagnostics.AddError("Update operation is not supported.", "Update operation is not supported.")

}

func (r *ObjectUserSecretKeyResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	tflog.Info(ctx, "Deleting Object user secret key")
	var state models.ObjectUserSecretKeyResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}
	ns := state.Namespace.ValueString()
	secret_key_id := state.Id.ValueString()
	// secret_key := state.SecretKey.ValueString()
	_, _, err := r.client.GenClient.UserSecretKeyApi.UserSecretKeyServiceDeleteKeyForUser(ctx, state.UserName.ValueString()).
		UserSecretKeyServiceDeleteKeyForUserRequest(clientgen.UserSecretKeyServiceDeleteKeyForUserRequest{
			Namespace:   &ns,
			SecretKeyId: &secret_key_id,
			SecretKey:   state.SecretKey.ValueStringPointer(),
		}).
		Execute()

	if err != nil {
		resp.Diagnostics.AddError(
			"Error Deleting Object user secret key",
			err.Error(),
		)
	}
}

func (r *ObjectUserSecretKeyResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	tflog.Info(ctx, "Importing Object user secret key")

	parts := strings.SplitN(req.ID, ":", 3)
	if len(parts) != 3 {
		resp.Diagnostics.AddError("Error importing Object user secret key", "invalid format: expected 'secretKeyId:username:namespace'")
		return
	}

	secretKeyId := parts[0]
	username := parts[1]
	namespace := parts[2]

	kResp, _, err := r.client.GenClient.UserSecretKeyApi.
		UserSecretKeyServiceGetKeysForUser(ctx, username).
		Execute()

	if err != nil {
		resp.Diagnostics.AddError("Error reading user secret key", err.Error())
		return
	}

	var data models.ObjectUserSecretKeyResourceModel
	if kResp != nil {
		exp_min := "Not available"
		if kResp.SecretKey1Id != nil && *kResp.SecretKey1Id == secretKeyId {
			data = models.ObjectUserSecretKeyResourceModel{
				Id:                 helper.TfString(kResp.SecretKey1Id),
				KeyExpiryTimestamp: helper.TfString(kResp.KeyExpiryTimestamp1),
				KeyTimestamp:       helper.TfString(kResp.KeyTimestamp1),
				UserName:           helper.TfString(&username),
				Namespace:          helper.TfString(&namespace),
				SecretKey:          helper.TfString(kResp.SecretKey1),
				ExpiryInMins:       helper.TfString(&exp_min),
			}
		} else if kResp.SecretKey2Id != nil && *kResp.SecretKey2Id == secretKeyId {
			data = models.ObjectUserSecretKeyResourceModel{
				Id:                 helper.TfString(kResp.SecretKey2Id),
				KeyExpiryTimestamp: helper.TfString(kResp.KeyExpiryTimestamp2),
				KeyTimestamp:       helper.TfString(kResp.KeyTimestamp2),
				UserName:           helper.TfString(&username),
				Namespace:          helper.TfString(&namespace),
				SecretKey:          helper.TfString(kResp.SecretKey2),
				ExpiryInMins:       helper.TfString(&exp_min),
			}
		}
	}
	// Save updated plan into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)

}
