/*
Copyright (c) 2025 Dell Inc., or its subsidiaries. All Rights Reserved.

Licensed under the Mozilla Public License Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://mozilla.org/MPL/2.0/


Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package provider

import (
	"context"
	"strings"
	"terraform-provider-objectscale/internal/clientgen"
	"terraform-provider-objectscale/internal/helper"
	"terraform-provider-objectscale/internal/models"

	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"

	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &IAMUserResource{}
var _ resource.ResourceWithImportState = &IAMUserResource{}

func NewIAMUserResource() resource.Resource {
	return &IAMUserResource{}
}

// IAMUserResource defines the resource implementation.
type IAMUserResource struct {
	resourceProviderConfig
}

func (r *IAMUserResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_iam_user"
}

func (r *IAMUserResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "ObjectScale supports creation and management of IAM Users within a namespace.",
		Description:         "ObjectScale supports creation and management of IAM Users within a namespace.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Description:         "Name of the user. Required.",
				MarkdownDescription: "Name of the user. Required.",
				Required:            true,
			},
			"id": schema.StringAttribute{
				Description:         "Identifier that is generated by ObjectScale when the resource is created.",
				MarkdownDescription: "Identifier that is generated by ObjectScale when the resource is created.",
				Computed:            true,
			},
			"arn": schema.StringAttribute{
				Description:         "Arn of the user.",
				MarkdownDescription: "Arn of the user.",
				Computed:            true,
			},
			"namespace": schema.StringAttribute{
				Description:         "Namespace to which the user belongs to.",
				MarkdownDescription: "Namespace to which the user belongs to.",
				Required:            true,
			},
			"create_date": schema.StringAttribute{
				Description:         "Date of creation of the IAM user",
				MarkdownDescription: "Date of creation of the IAM user",
				Computed:            true,
			},
			"path": schema.StringAttribute{
				Description:         "Path of the IAM user.",
				MarkdownDescription: "Path of the IAM user.",
				Computed:            true,
			},
			"permissions_boundary_arn": schema.StringAttribute{
				Description:         "Arn of the permissions boundary.",
				MarkdownDescription: "Arn of the permissions boundary.",
				Optional:            true,
				Computed:            true,
			},
			"permissions_boundary_type": schema.StringAttribute{
				Description:         "Type of the permissions boundary.",
				MarkdownDescription: "Type of the permissions boundary.",
				Computed:            true,
			},
			"tags": schema.SetNestedAttribute{
				Description:         "Tags associated to the user. Default: []. Updatable.",
				MarkdownDescription: "Tags associated to the user. Default: []. Updatable.",
				Optional:            true,
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"key": schema.StringAttribute{
							Description:         "Key of the tag associated to the user.",
							MarkdownDescription: "Key of the tag associated to the user.",
							Optional:            true,
							Computed:            true,
						},
						"value": schema.StringAttribute{
							Description:         "Value of the tag associated to the user.",
							MarkdownDescription: "Value of the tag associated to the user.",
							Optional:            true,
							Computed:            true,
						},
					},
				},
			},
		},
	}
}

func (r *IAMUserResource) tagJson(a models.Tags) clientgen.IamTagKeyValue {
	return clientgen.IamTagKeyValue{
		Key:   helper.ValueToPointer[string](a.Key),
		Value: helper.ValueToPointer[string](a.Value),
	}
}

func (r *IAMUserResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Info(ctx, "creating user")
	var plan models.IAMUserResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)

	if resp.Diagnostics.HasError() {
		return
	}

	_, _, err := r.client.GenClient.IamApi.IamServiceCreateUser(ctx).
		UserName(plan.Name.ValueString()).
		XEmcNamespace(plan.Namespace.ValueString()).
		PermissionsBoundary(plan.PermissionsBoundaryArn.ValueString()).
		TagsMemberN(helper.ValueListTransform(plan.Tags, r.tagJson)).
		Execute()
	if err != nil {
		resp.Diagnostics.AddError("Error creating user", err.Error())
		return
	}

	iam_user, _, err := r.client.GenClient.IamApi.IamServiceGetUser(ctx).
		UserName(plan.Name.ValueString()).
		XEmcNamespace(plan.Namespace.ValueString()).
		Execute()
	data := r.getModel(&clientgen.IamServiceGetUserResponseGetUserResultUser{
		UserId:              iam_user.GetUserResult.User.UserId,
		UserName:            iam_user.GetUserResult.User.UserName,
		Arn:                 iam_user.GetUserResult.User.Arn,
		CreateDate:          iam_user.GetUserResult.User.CreateDate,
		Path:                iam_user.GetUserResult.User.Path,
		PermissionsBoundary: iam_user.GetUserResult.User.PermissionsBoundary,
		Tags:                iam_user.GetUserResult.User.Tags,
	}, plan.Namespace)

	if err != nil {
		resp.Diagnostics.AddError("Error reading user", err.Error())
		return
	}

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *IAMUserResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	tflog.Info(ctx, "reading user")
	var state models.IAMUserResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	iam_user, _, err := r.client.GenClient.IamApi.IamServiceGetUser(ctx).
		UserName(state.Name.ValueString()).
		XEmcNamespace(state.Namespace.ValueString()).
		Execute()

	if err != nil {
		resp.Diagnostics.AddError("Error reading user", err.Error())
		return
	}

	data := r.getModel(&clientgen.IamServiceGetUserResponseGetUserResultUser{
		UserId:              iam_user.GetUserResult.User.UserId,
		UserName:            iam_user.GetUserResult.User.UserName,
		Arn:                 iam_user.GetUserResult.User.Arn,
		CreateDate:          iam_user.GetUserResult.User.CreateDate,
		Path:                iam_user.GetUserResult.User.Path,
		PermissionsBoundary: iam_user.GetUserResult.User.PermissionsBoundary,
		Tags:                iam_user.GetUserResult.User.Tags,
	}, state.Namespace)
	// Save updated plan into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *IAMUserResource) getModel(
	iam_user *clientgen.IamServiceGetUserResponseGetUserResultUser,
	namespace types.String) models.IAMUserResourceModel {
	var permissionsBoundaryArn, permissionsBoundaryType basetypes.StringValue

	// Check if PermissionsBoundary exists
	if iam_user.PermissionsBoundary != nil {
		permissionsBoundaryArn = helper.TfStringNN(iam_user.PermissionsBoundary.PermissionsBoundaryArn)
		permissionsBoundaryType = helper.TfStringNN(iam_user.PermissionsBoundary.PermissionsBoundaryType)
	} else {
		// Set empty values if missing
		permissionsBoundaryArn = types.StringValue("")
		permissionsBoundaryType = types.StringValue("")
	}
	return models.IAMUserResourceModel{

		Id:                      helper.TfStringNN(iam_user.UserId),
		Name:                    helper.TfStringNN(iam_user.UserName),
		Arn:                     helper.TfStringNN(iam_user.Arn),
		Namespace:               namespace,
		CreateDate:              helper.TfStringNN(iam_user.CreateDate),
		Path:                    helper.TfStringNN(iam_user.Path),
		PermissionsBoundaryType: permissionsBoundaryType,
		PermissionsBoundaryArn:  permissionsBoundaryArn,
		Tags: helper.SetNotNull(iam_user.Tags,
			func(v clientgen.IamServiceGetUserResponseGetUserResultUserTagsInner) types.Object {
				return helper.Object(models.Tags{
					Key:   helper.TfStringNN(v.Key),
					Value: helper.TfStringNN(v.Value),
				})
			}),
	}
}

// computes the difference between two Iam Tag sets (lists).
func iamTagsDiff(first, second []clientgen.IamTagKeyValue) []clientgen.IamTagKeyValue {
	var diff []clientgen.IamTagKeyValue
	type kv struct {
			Key   string
			Value string
		}
	smap := make(map[kv]struct{}, len(second))

	for _, v := range second {
		smap[kv{Key: *v.Key, Value: *v.Value}] = struct{}{}
	}
	for _, v := range first {
		if _, ok := smap[kv{Key: *v.Key, Value: *v.Value}]; !ok {
			diff = append(diff, v)
		}
	}
	return diff
}

func (r *IAMUserResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	tflog.Info(ctx, "updating user")

	var plan, state models.IAMUserResourceModel

	// Read Terraform plan and state data
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// Prevent non-updatable fields from being changed
	if !plan.Name.Equal(state.Name) {
		resp.Diagnostics.AddError("Error updating user", "Name is not updatable")
		return
	}

	if !plan.Tags.IsNull() || !plan.Tags.IsUnknown() || len(plan.Tags.Elements()) != 0 {
		tags_plan, tags_state := helper.ValueListTransform(plan.Tags, r.tagJson),
			helper.ValueListTransform(state.Tags, r.tagJson)

		tags_to_add, tags_to_remove := iamTagsDiff(tags_plan, tags_state),
			iamTagsDiff(tags_state, tags_plan)

		if len(tags_to_remove) != 0 {
			_, _, err_untag := r.client.GenClient.IamApi.IamServiceUntagUser(ctx).
				UserName(plan.Name.ValueString()).
				XEmcNamespace(plan.Namespace.ValueString()).
				TagKeys(helper.SliceTransform(
					tags_to_remove,
					func(a clientgen.IamTagKeyValue) clientgen.IamTagKey {
						return clientgen.IamTagKey{
							Key: a.Key,
						}
					})).
				Execute()
			if err_untag != nil {
				resp.Diagnostics.AddError("Error removing user tags", err_untag.Error())
				return
			}
		}

		if len(tags_to_add) != 0 {
			_, _, err_tag := r.client.GenClient.IamApi.IamServiceTagUser(ctx).
				UserName(plan.Name.ValueString()).
				XEmcNamespace(plan.Namespace.ValueString()).
				TagsMemberN(tags_to_add).
				Execute()
			if err_tag != nil {
				resp.Diagnostics.AddError("Error adding user tags", err_tag.Error())
				return
			}
		}
	}
	// Update permission boundary

	if !plan.PermissionsBoundaryArn.IsNull() {
		if plan.PermissionsBoundaryArn.ValueString() == "" && state.PermissionsBoundaryArn.ValueString() != "" {
			_, _, err := r.client.GenClient.IamApi.IamServiceDeleteUserPermissionsBoundary(ctx).
				UserName(plan.Name.ValueString()).
				XEmcNamespace(plan.Namespace.ValueString()).
				Execute()
			if err != nil {
				resp.Diagnostics.AddError("Error deleting permission boundary", err.Error())
				return
			}
		} else {
			_, _, err := r.client.GenClient.IamApi.IamServicePutUserPermissionsBoundary(ctx).
				UserName(plan.Name.ValueString()).
				XEmcNamespace(plan.Namespace.ValueString()).
				PermissionsBoundary(plan.PermissionsBoundaryArn.ValueString()).
				Execute()
			if err != nil {
				resp.Diagnostics.AddError("Error updating permission boundary", err.Error())
				return
			}
		}
	}
	// Refresh user data
	iam_user, _, err := r.client.GenClient.IamApi.IamServiceGetUser(ctx).
		UserName(state.Name.ValueString()).
		XEmcNamespace(state.Namespace.ValueString()).
		Execute()
	if err != nil {
		resp.Diagnostics.AddError("Error reading user", err.Error())
		return
	}

	data := r.getModel(&clientgen.IamServiceGetUserResponseGetUserResultUser{
		UserId:              iam_user.GetUserResult.User.UserId,
		UserName:            iam_user.GetUserResult.User.UserName,
		Arn:                 iam_user.GetUserResult.User.Arn,
		CreateDate:          iam_user.GetUserResult.User.CreateDate,
		Path:                iam_user.GetUserResult.User.Path,
		PermissionsBoundary: iam_user.GetUserResult.User.PermissionsBoundary,
		Tags:                iam_user.GetUserResult.User.Tags,
	}, state.Namespace)

	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *IAMUserResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	tflog.Info(ctx, "deleting IAM user")
	var state models.IAMUserResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	_, _, err := r.client.GenClient.IamApi.IamServiceDeleteUser(ctx).
		UserName(state.Name.ValueString()).
		XEmcNamespace(state.Namespace.ValueString()).
		Execute()

	if err != nil {
		resp.Diagnostics.AddError(
			"Error deleting IAM user",
			err.Error(),
		)
	}
}

func (r *IAMUserResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	tflog.Info(ctx, "importing IAM user")

	parts := strings.SplitN(req.ID, ":", 2)
	if len(parts) != 2 {
		resp.Diagnostics.AddError("Error importing IAM user", "invalid format: expected 'username:namespace'")
		return
	}
	username := parts[0]
	namespace := parts[1]

	iam_user, _, err := r.client.GenClient.IamApi.IamServiceGetUser(ctx).
		UserName(username).
		XEmcNamespace(namespace).
		Execute()

	if err != nil {
		resp.Diagnostics.AddError("Error reading user", err.Error())
		return
	}

	data := r.getModel(&clientgen.IamServiceGetUserResponseGetUserResultUser{
		UserId:              iam_user.GetUserResult.User.UserId,
		UserName:            iam_user.GetUserResult.User.UserName,
		Arn:                 iam_user.GetUserResult.User.Arn,
		CreateDate:          iam_user.GetUserResult.User.CreateDate,
		Path:                iam_user.GetUserResult.User.Path,
		PermissionsBoundary: iam_user.GetUserResult.User.PermissionsBoundary,
		Tags:                iam_user.GetUserResult.User.Tags,
	}, types.StringValue(namespace))
	// Save updated plan into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)

}
