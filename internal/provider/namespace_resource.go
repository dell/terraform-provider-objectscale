/*
Copyright (c) 2023-2024 Dell Inc., or its subsidiaries. All Rights Reserved.

Licensed under the Mozilla Public License Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://mozilla.org/MPL/2.0/


Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package provider

import (
	"context"
	"fmt"
	"terraform-provider-objectscale/internal/client"
	"terraform-provider-objectscale/internal/clientgen"
	"terraform-provider-objectscale/internal/helper"
	"terraform-provider-objectscale/internal/models"

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/setplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &NamespaceResource{}
var _ resource.ResourceWithImportState = &NamespaceResource{}

func NewNamespaceResource() resource.Resource {
	return &NamespaceResource{}
}

// NamespaceResource defines the resource implementation.
type NamespaceResource struct {
	client *client.Client
}

func (r *NamespaceResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_namespace"
}

func (r *NamespaceResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		// This description is used by the documentation generator and the language server.
		MarkdownDescription: "ObjectScale supports access by multiple tenants, where each tenant is defined by a namespace.",
		Description:         "ObjectScale supports access by multiple tenants, where each tenant is defined by a namespace.",
		Attributes: map[string]schema.Attribute{
			"name": schema.StringAttribute{
				Description:         "Name assigned to this resource in ObjectScale. The resource name is set by a user and can be changed at any time. It is not a unique identifier. Required.",
				MarkdownDescription: "Name assigned to this resource in ObjectScale. The resource name is set by a user and can be changed at any time. It is not a unique identifier. Required.",
				Required:            true,
			},
			"id": schema.StringAttribute{
				Description:         "Identifier that is generated by ObjectScale when the resource is created. The resource Id is guaranteed to be unique and immutable across all virtual data centers for all time.",
				MarkdownDescription: "Identifier that is generated by ObjectScale when the resource is created. The resource Id is guaranteed to be unique and immutable across all virtual data centers for all time.",
				Computed:            true,
			},
			"default_data_services_vpool": schema.StringAttribute{
				Description:         "Default replication group identifier for this tenant when creating buckets. Required. Updatable.",
				MarkdownDescription: "Default replication group identifier for this tenant when creating buckets. Required. Updatable.",
				Required:            true,
			},
			"allowed_vpools_list": schema.ListAttribute{
				Description:         "List of replication group that are allowed access to namespace.",
				MarkdownDescription: "List of replication group that are allowed access to namespace.",
				Optional:            true,
				Computed:            true,
				ElementType:         types.StringType,
			},
			"disallowed_vpools_list": schema.ListAttribute{
				Description:         "List of replication group that are not allowed access to namespace.",
				MarkdownDescription: "List of replication group that are not allowed access to namespace.",
				Optional:            true,
				Computed:            true,
				ElementType:         types.StringType,
			},
			"namespace_admins": schema.StringAttribute{
				Description:         "Comma separated list of namespace admins. Default: ''. Updatable.",
				MarkdownDescription: "Comma separated list of namespace admins. Default: ''. Updatable.",
				Optional:            true,
				Computed:            true,
			},
			"user_mapping": schema.ListNestedAttribute{
				Description:         "User Mapping. Default: []. Updatable.",
				MarkdownDescription: "User Mapping. Default: []. Updatable.",
				Optional:            true,
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"domain": schema.StringAttribute{
							Description:         "A single-valued attribute indicating the user's IDP domain",
							MarkdownDescription: "A single-valued attribute indicating the user's IDP domain",
							Optional:            true,
							Computed:            true,
						},
						"groups": schema.ListAttribute{
							Description:         "Groups.",
							MarkdownDescription: "Groups.",
							Optional:            true,
							Computed:            true,
							ElementType:         types.StringType,
						},
						"attributes": schema.ListNestedAttribute{
							Description:         "Attributes.",
							MarkdownDescription: "Attributes.",
							Optional:            true,
							Computed:            true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Description:         "Lookup string for this key-value pair",
										MarkdownDescription: "Lookup string for this key-value pair",
										Optional:            true,
										Computed:            true,
									},
									"value": schema.ListAttribute{
										Description:         "Lookup result for this key-value pair.",
										MarkdownDescription: "Lookup result for this key-value pair.",
										Optional:            true,
										Computed:            true,
										ElementType:         types.StringType,
									},
								},
							},
						},
					},
				},
			},
			"is_encryption_enabled": schema.BoolAttribute{
				Description:         "Encryption status of the namesapce. Default: false.",
				MarkdownDescription: "Encryption status of the namesapce. Default: false.",
				Computed:            true,
				Optional:            true,
			},
			"default_bucket_block_size": schema.Int64Attribute{
				Description:         "Default bucket quota size. Default: -1. Updatable.",
				MarkdownDescription: "Default bucket quota size. Default: -1. Updatable.",
				Optional:            true,
				Computed:            true,
			},
			"external_group_admins": schema.StringAttribute{
				Description:         "List of groups from AD Server. Default: ''. Updatable.",
				MarkdownDescription: "List of groups from AD Server. Default: ''. Updatable.",
				Optional:            true,
				Computed:            true,
			},
			"is_stale_allowed": schema.BoolAttribute{
				Description:         "Namespace isStaleAllowed flag. Default: false. Updatable..",
				MarkdownDescription: "Namespace isStaleAllowed flag. Default: false. Updatable..",
				Optional:            true,
				Computed:            true,
			},
			"is_object_lock_with_ado_allowed": schema.BoolAttribute{
				Description:         "Defines the default behavior for allowing Object Lock with ADO on new buckets created in the namespace. Default: false. Updatable.",
				MarkdownDescription: "Defines the default behavior for allowing Object Lock with ADO on new buckets created in the namespace. Default: false. Updatable.",
				Optional:            true,
				Computed:            true,
			},
			"is_compliance_enabled": schema.BoolAttribute{
				Description:         "Namespace isComplianceEnabled flag. Default: false.",
				MarkdownDescription: "Namespace isComplianceEnabled flag. Default: false.",
				Optional:            true,
				Computed:            true,
			},
			"quota": schema.SingleNestedAttribute{
				Description:         "Namespace Quota.",
				MarkdownDescription: "Namespace Quota.",
				Optional:            true,
				Computed:            true,
				Attributes: map[string]schema.Attribute{
					"notification_size": schema.Int64Attribute{
						Description:         "Notification Size in GB. Default: -1. Updatable.",
						MarkdownDescription: "Notification Size in GB. Default: -1. Updatable.",
						Optional:            true,
						Computed:            true,
					},
					"block_size": schema.Int64Attribute{
						Description:         "Block Size in GB. Default: -1. Updatable.",
						MarkdownDescription: "Block Size in GB. Default: -1. Updatable.",
						Optional:            true,
						Computed:            true,
					},
				},
			},
			"default_audit_delete_expiration": schema.Int64Attribute{
				Description:         "Default bucket audit delete expiration. Updatable.",
				MarkdownDescription: "Default bucket audit delete expiration. Updatable.",
				Optional:            true,
				Computed:            true,
			},
			"retention_classes": schema.SetNestedAttribute{
				Description:         "Retention Class.",
				MarkdownDescription: "Retention Class.",
				Optional:            true,
				Computed:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Description:         "Name of the retention class.",
							MarkdownDescription: "Name of the retention class.",
							Required:            true,
						},
						"period": schema.Int64Attribute{
							Description:         "Period of the retention class in seconds.",
							MarkdownDescription: "Period of the retention class in seconds.",
							Required:            true,
						},
					},
				},
			},
			"root_user_name": schema.StringAttribute{
				Description:         "root user name.",
				MarkdownDescription: "root user name.",
				Computed:            true,
			},
			"root_user_password": schema.StringAttribute{
				Description:         "root user password.",
				MarkdownDescription: "root user password.",
				Sensitive:           true,
				Optional:            true,
			},
			"current_root_user_password": schema.StringAttribute{
				Description:         "Current root user password. Only to be provided when updating the root user password.",
				MarkdownDescription: "Current root user password. Only to be provided when updating the root user password.",
				Sensitive:           true,
				Optional:            true,
			},
		},
	}
	resp.Schema.Attributes = fillSchemaWithUseState(resp.Schema.Attributes)
}

func fillSchemaWithUseState(in map[string]schema.Attribute) map[string]schema.Attribute {
	for key := range in {
		switch val := in[key].(type) {
		case schema.BoolAttribute:
			val.PlanModifiers = append(val.PlanModifiers, boolplanmodifier.UseStateForUnknown())
			in[key] = val
		case schema.Int64Attribute:
			val.PlanModifiers = append(val.PlanModifiers, int64planmodifier.UseStateForUnknown())
			in[key] = val
		case schema.SingleNestedAttribute:
			val.PlanModifiers = append(val.PlanModifiers, objectplanmodifier.UseStateForUnknown())
			in[key] = val
		case schema.StringAttribute:
			val.PlanModifiers = append(val.PlanModifiers, stringplanmodifier.UseStateForUnknown())
			in[key] = val
		case schema.ListNestedAttribute:
			val.PlanModifiers = append(val.PlanModifiers, listplanmodifier.UseStateForUnknown())
			in[key] = val
		case schema.ListAttribute:
			val.PlanModifiers = append(val.PlanModifiers, listplanmodifier.UseStateForUnknown())
			in[key] = val
		case schema.SetNestedAttribute:
			val.PlanModifiers = append(val.PlanModifiers, setplanmodifier.UseStateForUnknown())
			in[key] = val
		}
	}
	return in
}

func (r *NamespaceResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*client.Client)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *NamespaceResource) userMappingJson(u models.NsResUserMapping) clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerUserMappingInner {
	return clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerUserMappingInner{
		Domain:     u.Domain.ValueString(),
		Attributes: helper.ValueListTransform(u.Attributes, r.userMappingAttrJson),
		Groups:     helper.ValueToList[string](u.Groups),
	}
}

func (r *NamespaceResource) userMappingAttrJson(a models.NsResUserMappingAttr) clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerUserMappingInnerAttributesInner {
	return clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerUserMappingInnerAttributesInner{
		Key:   a.Key.ValueString(),
		Value: helper.ValueToList[string](a.Value),
	}
}

func (r *NamespaceResource) boolToString(b *bool) *string {
	if b == nil {
		return nil
	}
	ret := "false"
	if *b {
		ret = "true"
	}
	return &ret
}

func (r *NamespaceResource) stringToBool(s *string) *bool {
	if s == nil {
		return nil
	}
	ret := *s == "true"

	return &ret
}

func (r *NamespaceResource) quotaJson(in models.NsResQuota) clientgen.NamespaceServiceGetNamespaceResponse {
	return clientgen.NamespaceServiceGetNamespaceResponse{
		NotificationSize: helper.SetDefault(helper.ValueToPointer[int64](in.NotificationSize), -1),
		BlockSize:        helper.SetDefault(helper.ValueToPointer[int64](in.BlockSize), -1),
	}
}

func (r *NamespaceResource) modelToJson(plan models.NamespaceResourceModel) clientgen.NamespaceServiceGetNamespaceResponse {
	pQuota := helper.ValueObjectTransform(plan.Quota, r.quotaJson)
	return clientgen.NamespaceServiceGetNamespaceResponse{
		Id:                           helper.ValueToPointer[string](plan.Id),
		Name:                         helper.ValueToPointer[string](plan.Name),
		DefaultDataServicesVpool:     helper.ValueToPointer[string](plan.DefaultDataServicesVpool),
		AllowedVpoolsList:            helper.ValueToList[string](plan.AllowedVpoolsList),
		DisallowedVpoolsList:         helper.ValueToList[string](plan.DisallowedVpoolsList),
		NamespaceAdmins:              helper.ValueToPointer[string](plan.NamespaceAdmins),
		UserMapping:                  helper.ValueListTransform(plan.UserMapping, r.userMappingJson),
		IsEncryptionEnabled:          r.boolToString(helper.ValueToPointer[bool](plan.IsEncryptionEnabled)),
		DefaultBucketBlockSize:       helper.ValueToPointer[int64](plan.DefaultBucketBlockSize),
		ExternalGroupAdmins:          helper.ValueToPointer[string](plan.ExternalGroupAdmins),
		IsStaleAllowed:               helper.ValueToPointer[bool](plan.IsStaleAllowed),
		IsObjectLockWithAdoAllowed:   helper.ValueToPointer[bool](plan.IsObjectLockWithAdoAllowed),
		IsComplianceEnabled:          helper.ValueToPointer[bool](plan.IsComplianceEnabled),
		DefaultAuditDeleteExpiration: helper.ValueToPointer[int64](plan.DefaultAuditDeleteExpiration),
		RetentionClasses: &clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerRetentionClasses{
			RetentionClass: helper.ValueListTransform(plan.RetentionClasses, r.rcListJson),
		},
		NotificationSize: pQuota.NotificationSize,
		BlockSize:        pQuota.BlockSize,
	}
}

func (r *NamespaceResource) rcListJson(in models.RetentionClass) clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerRetentionClassesRetentionClassInner {
	return clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerRetentionClassesRetentionClassInner{
		Name:   helper.ValueToPointer[string](in.Name),
		Period: helper.ValueToPointer[int64](in.Period),
	}
}

func (r *NamespaceResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	tflog.Info(ctx, "creating namespace")
	var plan models.NamespaceResourceModel

	// Read Terraform plan data into the model
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}
	planJson := r.modelToJson(plan)

	nsreq := r.client.GenClient.NamespaceApi.NamespaceServiceCreateNamespace(ctx)
	namespace, _, err := nsreq.NamespaceServiceCreateNamespaceRequest(
		clientgen.NamespaceServiceCreateNamespaceRequest{
			Namespace:                    *planJson.Name,
			DefaultDataServicesVpool:     planJson.DefaultDataServicesVpool,
			AllowedVpoolsList:            planJson.AllowedVpoolsList,
			DisallowedVpoolsList:         planJson.DisallowedVpoolsList,
			NamespaceAdmins:              planJson.NamespaceAdmins,
			UserMapping:                  planJson.UserMapping,
			IsEncryptionEnabled:          r.stringToBool(planJson.IsEncryptionEnabled),
			DefaultBucketBlockSize:       planJson.DefaultBucketBlockSize,
			ExternalGroupAdmins:          planJson.ExternalGroupAdmins,
			IsStaleAllowed:               planJson.IsStaleAllowed,
			IsObjectLockWithAdoAllowed:   planJson.IsObjectLockWithAdoAllowed,
			ComplianceEnabled:            planJson.IsComplianceEnabled,
			DefaultAuditDeleteExpiration: planJson.DefaultAuditDeleteExpiration,
			RootUserPassword:             helper.ValueToPointer[string](plan.RootUserPassword),
		}).Execute()
	if err != nil {
		resp.Diagnostics.AddError("Error creating namespace", err.Error())
		return
	}

	stateJson1 := &clientgen.NamespaceServiceGetNamespaceResponse{
		Id:                           namespace.Id,
		Name:                         namespace.Name,
		DefaultDataServicesVpool:     namespace.DefaultDataServicesVpool,
		AllowedVpoolsList:            namespace.AllowedVpoolsList,
		DisallowedVpoolsList:         namespace.DisallowedVpoolsList,
		NamespaceAdmins:              namespace.NamespaceAdmins,
		UserMapping:                  namespace.UserMapping,
		IsEncryptionEnabled:          namespace.IsEncryptionEnabled,
		DefaultBucketBlockSize:       namespace.DefaultBucketBlockSize,
		ExternalGroupAdmins:          namespace.ExternalGroupAdmins,
		IsStaleAllowed:               namespace.IsStaleAllowed,
		IsObjectLockWithAdoAllowed:   namespace.IsObjectLockWithAdoAllowed,
		IsComplianceEnabled:          namespace.IsComplianceEnabled,
		RetentionClasses:             namespace.RetentionClasses,
		DefaultAuditDeleteExpiration: namespace.DefaultAuditDeleteExpiration,
		NotificationSize:             namespace.NotificationSize,
		BlockSize:                    namespace.BlockSize,
		RootUserName:                 namespace.RootUserName,
	}
	data := r.getModel(stateJson1, plan.RootUserPassword, plan.CurrentRootUserPassword)

	// Save data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)

	// update common workflow
	stateJson2, errd := r.updateCommon(ctx, &planJson, stateJson1)
	if errd != nil {
		resp.Diagnostics.AddError(errd.Summary, errd.Detail)
		return
	}

	// Save data into Terraform state
	data = r.getModel(stateJson2, plan.RootUserPassword, plan.CurrentRootUserPassword)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)

}

func (r *NamespaceResource) updateCommon(ctx context.Context, plan, state *clientgen.NamespaceServiceGetNamespaceResponse) (*clientgen.NamespaceServiceGetNamespaceResponse, *models.DiagError) {
	// update retention classes
	statercs, planrcs := r.getRCMap(state), r.getRCMap(plan)
	err := r.manageRetentionClasses(ctx, *state.Id, statercs, planrcs)
	if err != nil {
		return nil, &models.DiagError{
			Summary: "Error adding retention classes",
			Detail:  err.Error(),
		}
	}

	// add quotas
	err = r.manageQuotas(ctx, state, plan)
	if err != nil {
		return nil, &models.DiagError{
			Summary: "Error adding quotas",
			Detail:  err.Error(),
		}
	}

	// read data
	state2, _, err := r.client.GenClient.NamespaceApi.NamespaceServiceGetNamespace(ctx, *state.Id).Execute()
	if err != nil {
		return nil, &models.DiagError{
			Summary: "Error reading namespace after adding retention classes",
			Detail:  err.Error(),
		}
	}

	return state2, nil
}

func (r *NamespaceResource) manageQuotas(ctx context.Context, state, plan *clientgen.NamespaceServiceGetNamespaceResponse) error {
	if *plan.NotificationSize == *state.NotificationSize &&
		*plan.BlockSize == *state.BlockSize {
		return nil
	}
	_, _, err := r.client.GenClient.NamespaceApi.
		NamespaceServiceUpdateNamespaceQuota(ctx, *state.Id).
		NamespaceServiceUpdateNamespaceQuotaRequest(clientgen.NamespaceServiceUpdateNamespaceQuotaRequest{
			NotificationSize: plan.NotificationSize,
			BlockSize:        plan.BlockSize,
		}).
		Execute()
	return err
}

func (r *NamespaceResource) manageRetentionClasses(ctx context.Context, id string, state, plan map[string]int64) error {
	for name, period := range plan {
		if speriod, ok := state[name]; !ok {
			// create
			_, _, err := r.client.GenClient.NamespaceApi.NamespaceServiceCreateRetentionClass(ctx, id).
				NamespaceServiceCreateRetentionClassRequest(clientgen.NamespaceServiceCreateRetentionClassRequest{
					Name:   &name,
					Period: &period,
				}).
				Execute()

			if err != nil {
				return err
			}
		} else if speriod != period {
			// update
			_, _, err := r.client.GenClient.NamespaceApi.NamespaceServiceUpdateRetentionClass(ctx, id, name).
				NamespaceServiceUpdateRetentionClassRequest(clientgen.NamespaceServiceUpdateRetentionClassRequest{
					Period: &period,
				}).
				Execute()
			if err != nil {
				return err
			}
		}
	}
	return nil
}

func (r *NamespaceResource) getRCMap(in *clientgen.NamespaceServiceGetNamespaceResponse) map[string]int64 {
	classes := r.deNilRCList(in)
	ret := make(map[string]int64, len(classes))
	for _, class := range classes {
		ret[*class.Name] = *class.Period
	}
	return ret
}

func (r *NamespaceResource) deNilRCList(in *clientgen.NamespaceServiceGetNamespaceResponse) []clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerRetentionClassesRetentionClassInner {
	if in.RetentionClasses == nil {
		return make([]clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerRetentionClassesRetentionClassInner, 0)
	}
	return in.RetentionClasses.RetentionClass
}

func (r *NamespaceResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	tflog.Info(ctx, "reading namespace")
	var state models.NamespaceResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	namespace, _, err := r.client.GenClient.NamespaceApi.NamespaceServiceGetNamespace(ctx, state.Id.ValueString()).Execute()

	if err != nil {
		resp.Diagnostics.AddError("Error reading namespace", err.Error())
		return
	}

	data := r.getModel(namespace, state.RootUserPassword, state.CurrentRootUserPassword)
	// Save updated plan into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NamespaceResource) getModel(
	namespace *clientgen.NamespaceServiceGetNamespaceResponse,
	rootpwd, crootpwd types.String) models.NamespaceResourceModel {
	IsEncryptionEnabled := namespace.IsEncryptionEnabled != nil && *namespace.IsEncryptionEnabled == "true"

	return models.NamespaceResourceModel{
		Id:                       helper.TfStringNN(namespace.Id),
		Name:                     helper.TfStringNN(namespace.Name),
		DefaultDataServicesVpool: helper.TfStringNN(namespace.DefaultDataServicesVpool),
		AllowedVpoolsList:        helper.ListNotNull(namespace.AllowedVpoolsList, types.StringValue),
		DisallowedVpoolsList:     helper.ListNotNull(namespace.DisallowedVpoolsList, types.StringValue),
		NamespaceAdmins:          helper.TfStringNN(namespace.NamespaceAdmins),
		UserMapping: helper.ListNotNull(namespace.UserMapping,
			func(v clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerUserMappingInner) types.Object {
				return helper.Object(models.NsResUserMapping{
					Domain: types.StringValue(v.Domain),
					Attributes: helper.ListNotNull(v.Attributes,
						func(via clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerUserMappingInnerAttributesInner) types.Object {
							return helper.Object(models.NsResUserMappingAttr{
								Key:   types.StringValue(via.Key),
								Value: helper.ListNotNull(via.Value, types.StringValue),
							})
						}),
					Groups: helper.ListNotNull(v.Groups, types.StringValue),
				})
			}),
		IsEncryptionEnabled:        helper.TfBoolNN(&IsEncryptionEnabled),
		DefaultBucketBlockSize:     helper.TfInt64NN(namespace.DefaultBucketBlockSize),
		ExternalGroupAdmins:        helper.TfStringNN(namespace.ExternalGroupAdmins),
		IsStaleAllowed:             helper.TfBoolNN(namespace.IsStaleAllowed),
		IsObjectLockWithAdoAllowed: helper.TfBoolNN(namespace.IsObjectLockWithAdoAllowed),
		IsComplianceEnabled:        helper.TfBoolNN(namespace.IsComplianceEnabled),
		RetentionClasses: helper.SetNotNull(r.deNilRCList(namespace),
			func(v clientgen.NamespaceServiceGetNamespacesResponseNamespaceInnerRetentionClassesRetentionClassInner) types.Object {
				return helper.Object(models.RetentionClass{
					Name:   helper.TfStringNN(v.Name),
					Period: helper.TfInt64NN(v.Period),
				})
			}),
		Quota: helper.Object(models.NsResQuota{
			NotificationSize: helper.TfInt64NN(namespace.NotificationSize),
			BlockSize:        helper.TfInt64NN(namespace.BlockSize),
		}),
		DefaultAuditDeleteExpiration: helper.TfInt64NN(namespace.DefaultAuditDeleteExpiration),
		RootUserName:                 helper.TfStringNN(namespace.RootUserName),
		RootUserPassword:             rootpwd,
		CurrentRootUserPassword:      crootpwd,
	}
}

// computes the difference between two string sets (lists).
func (r *NamespaceResource) vpoolDiff(first, second []string) []string {
	var diff []string
	smap := make(map[string]struct{}, len(second))
	for _, v := range second {
		smap[v] = struct{}{}
	}
	for _, v := range first {
		if _, ok := smap[v]; !ok {
			diff = append(diff, v)
		}
	}
	return diff
}

func (r *NamespaceResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	tflog.Info(ctx, "updating namespace")
	var plan, state models.NamespaceResourceModel

	// Read Terraform plan and state data into the models
	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

	// To prevent the non-updatable fields from being changed
	if !plan.Name.Equal(state.Name) ||
		!plan.IsComplianceEnabled.Equal(state.IsComplianceEnabled) ||
		!plan.IsEncryptionEnabled.Equal(state.IsEncryptionEnabled) {
		resp.Diagnostics.AddError("Error updating namespace",
			"Fields of `name`, `is_compliance_enabled` and `is_encryption_enabled` are not updatable")
	}

	planJson, stateJson := r.modelToJson(plan), r.modelToJson(state)

	statercs, planrcs := r.getRCMap(&stateJson), r.getRCMap(&planJson)
	for name := range statercs {
		if _, ok := planrcs[name]; !ok {
			// delete
			resp.Diagnostics.AddError(
				"Error updating namespace",
				"removal of retention classes from namespace is not supported")
		}
	}

	if resp.Diagnostics.HasError() {
		return
	}

	var currpass, newpass *string
	// if root password is changing
	if helper.IsChangedNN(plan.RootUserPassword, state.RootUserPassword) {
		currpass = helper.ValueToPointer[string](plan.CurrentRootUserPassword)
		newpass = helper.ValueToPointer[string](plan.RootUserPassword)
	}

	ureq := r.client.GenClient.NamespaceApi.NamespaceServiceUpdateNamespace(ctx, state.Id.ValueString())
	ureq = ureq.NamespaceServiceUpdateNamespaceRequest(clientgen.NamespaceServiceUpdateNamespaceRequest{
		DefaultDataServicesVpool: planJson.DefaultDataServicesVpool,
		// vpools
		VpoolsAddedToAllowedVpoolsList: r.vpoolDiff(
			planJson.AllowedVpoolsList,
			stateJson.AllowedVpoolsList),
		VpoolsRemovedFromAllowedVpoolsList: r.vpoolDiff(
			stateJson.AllowedVpoolsList,
			planJson.AllowedVpoolsList),
		VpoolsAddedToDisallowedVpoolsList: r.vpoolDiff(
			planJson.DisallowedVpoolsList,
			stateJson.DisallowedVpoolsList),
		VpoolsRemovedFromDisallowedVpoolsList: r.vpoolDiff(
			stateJson.DisallowedVpoolsList,
			planJson.DisallowedVpoolsList),

		NamespaceAdmins:              planJson.NamespaceAdmins,
		UserMapping:                  planJson.UserMapping,
		DefaultBucketBlockSize:       planJson.DefaultBucketBlockSize,
		ExternalGroupAdmins:          planJson.ExternalGroupAdmins,
		IsStaleAllowed:               planJson.IsStaleAllowed,
		IsObjectLockWithAdoAllowed:   planJson.IsObjectLockWithAdoAllowed,
		DefaultAuditDeleteExpiration: planJson.DefaultAuditDeleteExpiration,

		// root user password
		CurrentRootUserPassword: currpass,
		NewRootUserPassword:     newpass,
	})
	_, _, err := ureq.Execute()
	if err != nil {
		resp.Diagnostics.AddError("Error updating namespace", err.Error())
		return
	}

	// update common workflow
	namespace, errd := r.updateCommon(ctx, &planJson, &stateJson)
	if errd != nil {
		resp.Diagnostics.AddError(errd.Summary, errd.Detail)
		return
	}

	// Save updated data into Terraform state
	data := r.getModel(namespace, plan.RootUserPassword, plan.CurrentRootUserPassword)
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *NamespaceResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	tflog.Info(ctx, "deleting namespace")
	var state models.NamespaceResourceModel

	// Read Terraform prior state data into the model
	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)

	if resp.Diagnostics.HasError() {
		return
	}

	_, _, err := r.client.GenClient.NamespaceApi.NamespaceServiceDeactivateNamespace(ctx, state.Id.ValueString()).Execute()

	if err != nil {
		resp.Diagnostics.AddError(
			"Error deleting namespace",
			err.Error(),
		)
	}
}

func (r *NamespaceResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), req, resp)
}
